package Strategies

import Cell
import Puzzle
import org.junit.jupiter.api.Test

import org.junit.jupiter.api.Assertions.*

internal class OnlyOnePossibilityStrategyTest {

    @Test
    fun findApplicableCellsAndApplyChanges() {
        val cell1 = Cell("1")
        cell1.setPossibleValues(listOf())
        cell1.setRow(0)
        cell1.setColumn(0)
        cell1.setBoxId(0)
        val cell2 = Cell("-")
        cell2.setPossibleValues(listOf("1", "2", "3", "4"))
        cell2.setRow(0)
        cell2.setColumn(1)
        cell2.setBoxId(0)
        val cell3 = Cell("3")
        cell3.setPossibleValues(listOf())
        cell3.setRow(0)
        cell3.setColumn(2)
        cell3.setBoxId(1)
        val cell4 = Cell("4")
        cell4.setPossibleValues(listOf())
        cell4.setRow(0)
        cell4.setColumn(3)
        cell4.setBoxId(1)
        val list1 = mutableListOf(cell1, cell2, cell3, cell4)

        val cell5 = Cell("-")
        cell5.setPossibleValues(listOf())
        cell5.setRow(1)
        cell5.setColumn(0)
        cell5.setBoxId(0)
        val cell6 = Cell("3")
        cell6.setPossibleValues(listOf())
        cell6.setRow(1)
        cell6.setColumn(1)
        cell6.setBoxId(0)
        val cell7 = Cell("4")
        cell7.setPossibleValues(listOf())
        cell7.setRow(1)
        cell7.setColumn(2)
        cell7.setBoxId(1)
        val cell8 = Cell("1")
        cell8.setPossibleValues(listOf())
        cell8.setRow(1)
        cell8.setColumn(3)
        cell8.setBoxId(1)
        val list2 = mutableListOf(cell5, cell6, cell7, cell8)

        val cell9 = Cell("3")
        cell9.setPossibleValues(listOf())
        cell9.setRow(2)
        cell9.setColumn(0)
        cell9.setBoxId(2)
        val cell10 = Cell("4")
        cell10.setPossibleValues(listOf())
        cell10.setRow(2)
        cell10.setColumn(1)
        cell10.setBoxId(2)
        val cell11 = Cell("-")
        cell11.setPossibleValues(listOf("1", "2", "3", "4"))
        cell11.setRow(2)
        cell11.setColumn(2)
        cell11.setBoxId(3)
        val cell12 = Cell("2")
        cell12.setPossibleValues(listOf())
        cell12.setRow(2)
        cell12.setColumn(3)
        cell12.setBoxId(3)
        val list3 = mutableListOf(cell9, cell10, cell11, cell12)

        val cell13 = Cell("4")
        cell13.setPossibleValues(listOf())
        cell13.setRow(3)
        cell13.setColumn(0)
        cell13.setBoxId(2)
        val cell14 = Cell("1")
        cell14.setPossibleValues(listOf())
        cell14.setRow(3)
        cell14.setColumn(1)
        cell14.setBoxId(2)
        val cell15 = Cell("2")
        cell15.setPossibleValues(listOf())
        cell15.setRow(3)
        cell15.setColumn(2)
        cell15.setBoxId(3)
        val cell16 = Cell("-")
        cell16.setPossibleValues(listOf("1", "2", "3", "4"))
        cell16.setRow(3)
        cell16.setColumn(3)
        cell16.setBoxId(3)
        val list4 = mutableListOf(cell13, cell14, cell15, cell16)

        val myPuzzle = Puzzle
        myPuzzle.setSize(4)
        myPuzzle.setValidSymbols(listOf("1", "2", "3", "4"))

        myPuzzle.board.add(0, list1)
        myPuzzle.board.add(1, list2)
        myPuzzle.board.add(2, list3)
        myPuzzle.board.add(3, list4)

        val myStrategy = OnlyOnePossibilityStrategy()
        val result = myStrategy.findApplicableCells(myPuzzle)
        assertNotNull(result)
        val changes = myStrategy.applyChanges(myPuzzle, result.first, result.second)
        assertNotNull(changes)
    }
}